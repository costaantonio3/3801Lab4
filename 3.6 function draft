function [Fc, Gc] = VelocityReferenceFeedback(t, var)
%
% Inputs:
%   t   : current time (scalar)
%   var : 12x1 aircraft state vector
%         [xE yE zE u v w phi theta psi p q r]^T
%
% Outputs:
%   Fc : 3x1 body-force vector [0; 0; m*g]
%   Gc : 3x1 body-moment vector [ΔL_c; ΔM_c; ΔN_c] 
%

% Hard-coded quad parameters (hover linearization)
m  = 0.068;     % kg
g  = 9.81;      % m/s^2
Ix = 5.8e-5;   % kg*m^2 (roll)
Iy = 7.2e-5;   % kg*m^2 (pitch)
Iz = 1.0e-4;   % kg*m^2 (yaw)

% Gains from 3.1 / 3.2
sum_p  = 8;  % -(lambda_dom + lambda_fast)
prod_p = 12; % (lambda_dom * lambda_fast)

% Gains for inner loop
k1_phi = prod_p * Ix;  % angle gain for roll (φ)
k2_p   = sum_p  * Ix;  % rate  gain for roll (p)
k1_th  = prod_p * Iy;  % angle gain for pitch (θ)
k2_q   = sum_p  * Iy;  % rate  gain for pitch (q)
k_r    = 0.004;        % yaw rate damper gain (from Prob 2.3)

% %
% % --- GAINS FROM 3.5 (OUTER VELOCITY LOOP) ---
% % TODO: Fill in these k3 gains
%
k3_lat = 0.0;  % PLACEHOLDER for lateral velocity gain (controls roll)
k3_lon = 0.0;  % PLACEHOLDER for longitudinal velocity gain (controls pitch)
%
% %

% ----------------- FEEDFORWARD COMMANDS (3.6) -------------------------
% Design: Move 1.0 m in 2.0 s, then come to rest.
% Assuming instantaneous speed tracking, a constant speed is
% needed.
% Required speed = distance / time = 1.0 m / 2.0 s = 0.5 m/s.
% The command is 0.5 m/s for 0 <= t <= 2.0, and 0.0 m/s after.

t_command_end = 2.0; % [s]
v_ref_const   = 0.5; % [m/s]

if t <= t_command_end
    delta_u_r = v_ref_const; % Longitudinal speed command (for x-motion)
    delta_v_r = v_ref_const; % Lateral speed command (for y-motion)
else
    delta_u_r = 0.0; % Command ends after 2.0s
    delta_v_r = 0.0;
end
% Note: 3.7 simulates longitudinal and lateral moves "one at a time"
% so the actual script should set one of these to 0
% when testing the other.

u     = var(4);  % body-x velocity
v     = var(5);  % body-y velocity
phi   = var(7);  % roll angle
theta = var(8);  % pitch angle
p     = var(10); % roll rate
q     = var(11); % pitch rate
r     = var(12); % yaw rate

% Control Law from 3.1 + 3.5 + 3.6

% Lateral / Roll control (ΔLc)
% ΔLc = [Inner Loop] + [Outer Loop]
% ΔLc = -(k1_phi*phi + k2_p*p) + k3_lat*(delta_v_r - v)
dLc = -(k1_phi*phi + k2_p*p) + k3_lat*(delta_v_r - v);

% Longitudinal / Pitch control (ΔMc)
% Positive (u_r - u) error must create a negative (pitch down) moment.
% ΔMc = [Inner Loop] - [Outer Loop]
% ΔMc = -(k1_th*theta + k2_q*q) - k3_lon*(delta_u_r - u)
dMc = -(k1_th*theta + k2_q*q) - k3_lon*(delta_u_r - u);

% Directional / Yaw control (ΔNc)
% Just the rate damper from 2.3/3.1
dNc = -(k_r*r);

% Outputs
% Control force vector (hover thrust)
Fc = [0; 0; m*g];

% Control moment vector
Gc = [dLc; dMc; dNc];

end
