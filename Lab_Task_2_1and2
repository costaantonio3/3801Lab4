%% Lab Task 2: Hover IC deviations (Nonlinear vs Linearized) 
clear; clc; close all;

%% PLOTTING FUNCTION

function PlotAircraftSim(time, aircraft_state_array, control_input_array, fig, col)
% PlotAircraftSim: Plots the results of a full simulation
% Inputs:
%   time - n x 1 vector of time values
%   aircraft_state_array - 12 x n array of aircraft states
%   control_input_array - 4 x n array of control inputs [Zc; Lc; Mc; Nc]
%   fig - 6 x 1 vector of figure numbers to plot
%   col - plotting color/style (e.g., 'b-', 'r--')

% Figure 1: Inertial Position (x, y, z)
figure(fig(1));
subplot(3,1,1);
plot(time, aircraft_state_array(1,:), col); hold on;
xlabel('Time (s)'); ylabel('x (m)'); title('X Position'); grid on;
subplot(3,1,2);
plot(time, aircraft_state_array(2,:), col); hold on;
xlabel('Time (s)'); ylabel('y (m)'); title('Y Position'); grid on;
subplot(3,1,3);
plot(time, aircraft_state_array(3,:), col); hold on;
xlabel('Time (s)'); ylabel('z (m)'); title('Z Position'); grid on;

% Figure 2: Euler Angles (phi, theta, psi)
figure(fig(2));
subplot(3,1,1);
plot(time, rad2deg(aircraft_state_array(7,:)), col); hold on;
xlabel('Time (s)'); ylabel('\phi (deg)'); title('Roll Angle'); grid on;
subplot(3,1,2);
plot(time, rad2deg(aircraft_state_array(8,:)), col); hold on;
xlabel('Time (s)'); ylabel('\theta (deg)'); title('Pitch Angle'); grid on;
subplot(3,1,3);
plot(time, rad2deg(aircraft_state_array(9,:)), col); hold on;
xlabel('Time (s)'); ylabel('\psi (deg)'); title('Yaw Angle'); grid on;

% Figure 3: Inertial Velocity in Body Frame (u, v, w)
figure(fig(3));
subplot(3,1,1);
plot(time, aircraft_state_array(4,:), col); hold on;
xlabel('Time (s)'); ylabel('u (m/s)'); title('Body X Velocity'); grid on;
subplot(3,1,2);
plot(time, aircraft_state_array(5,:), col); hold on;
xlabel('Time (s)'); ylabel('v (m/s)'); title('Body Y Velocity'); grid on;
subplot(3,1,3);
plot(time, aircraft_state_array(6,:), col); hold on;
xlabel('Time (s)'); ylabel('w (m/s)'); title('Body Z Velocity'); grid on;

% Figure 4: Angular Velocity (p, q, r)
figure(fig(4));
subplot(3,1,1);
plot(time, rad2deg(aircraft_state_array(10,:)), col); hold on;
xlabel('Time (s)'); ylabel('p (deg/s)'); title('Roll Rate'); grid on;
subplot(3,1,2);
plot(time, rad2deg(aircraft_state_array(11,:)), col); hold on;
xlabel('Time (s)'); ylabel('q (deg/s)'); title('Pitch Rate'); grid on;
subplot(3,1,3);
plot(time, rad2deg(aircraft_state_array(12,:)), col); hold on;
xlabel('Time (s)'); ylabel('r (deg/s)'); title('Yaw Rate'); grid on;

% Figure 5: Control Inputs (Zc, Lc, Mc, Nc)
figure(fig(5));
subplot(4,1,1);
plot(time, control_input_array(1,:), col); hold on;
xlabel('Time (s)'); ylabel('Z_c (N)'); title('Control Force Z'); grid on;
subplot(4,1,2);
plot(time, control_input_array(2,:), col); hold on;
xlabel('Time (s)'); ylabel('L_c (N*m)'); title('Control Moment L (Roll)'); grid on;
subplot(4,1,3);
plot(time, control_input_array(3,:), col); hold on;
xlabel('Time (s)'); ylabel('M_c (N*m)'); title('Control Moment M (Pitch)'); grid on;
subplot(4,1,4);
plot(time, control_input_array(4,:), col); hold on;
xlabel('Time (s)'); ylabel('N_c (N*m)'); title('Control Moment N (Yaw)'); grid on;

% Figure 6: 3D Path
figure(fig(6));
plot3(aircraft_state_array(1,:), aircraft_state_array(2,:), -aircraft_state_array(3,:), col); hold on;
% Mark start (green) and finish (red)
plot3(aircraft_state_array(1,1), aircraft_state_array(2,1), -aircraft_state_array(3,1), ...
      'go', 'MarkerSize', 10, 'MarkerFaceColor', 'g');
plot3(aircraft_state_array(1,end), aircraft_state_array(2,end), -aircraft_state_array(3,end), ...
      'rs', 'MarkerSize', 10, 'MarkerFaceColor', 'r');
xlabel('X (m)'); ylabel('Y (m)'); zlabel('Height (m)');
title('3D Aircraft Path'); grid on; axis equal;
view(3);
end


%% PARAMETERS 
m  = 0.068;            % kg
g  = 9.81;             % m/s^2
d  = 0.060;            % m
km = 0.0024;           % N*m/N
I  = diag([5.8e-5, 7.2e-5, 1.0e-4]);   % kg*m^2  (Ix, Iy, Iz)
nu = 1e-3;             % N/(m/s)^2 (nonlinear aero drag coefficient)
mu = 2e-6;             % N*m/(rad/s)^2 (nonlinear aero moment coefficient)

t_span = [0 10];                           
opts   = odeset('RelTol',1e-6,'AbsTol',1e-8);

% Hover trim state and trim inputs (level hover at origin) 
var_trim = zeros(12,1);                    
Zc0      = -m*g;            % body +Z control 
motor_forces_trim = control_to_motors(Zc0, 0, 0, 0, d, km);

% Six Initial-Condition deviations about hover (no control changes)
nCases = 6;
ICs = repmat(var_trim,1,nCases);
ICs(7,1)  = deg2rad(5);   % a) +5 deg roll
ICs(8,2)  = deg2rad(5);   % b) +5 deg pitch
ICs(9,3)  = deg2rad(5);   % c) +5 deg yaw
ICs(10,4) = 0.1;         % d) +0.1 rad/s roll rate
ICs(11,5) = 0.1;         % e) +0.1 rad/s pitch rate
ICs(12,6) = 0.1;         % f) +0.1 rad/s yaw rate

caseNames = { ...
    '+5 deg roll (IC only)'; ...
    '+5 deg pitch (IC only)'; ...
    '+5 deg yaw (IC only)'; ...
    '+0.1 rad/s roll rate (IC only)'; ...
    '+0.1 rad/s pitch rate (IC only)'; ...
    '+0.1 rad/s yaw rate (IC only)' };

% Controls for linear model 
deltaFc = 0;  % ΔZc (N)
deltaGc = [0;0;0];  % [ΔLc; ΔMc; ΔNc] (N*m)

%% RUN ALL SIX DEVIATION CASES 
for k = 1:nCases
    % Nonlinear sim (blue)
    x0_nl = ICs(:,k);
    [tNL, xNL] = ode45(@(t,x) QuadrotorEOM(t, x, g,m,I,d,km,nu,mu, motor_forces_trim), ...
                       t_span, x0_nl, opts);
    X_NL = xNL.';                 % 12 x n
    nN   = numel(tNL);

    % Control inputs (hold hover trim motors constant)
    f1 = motor_forces_trim(1); f2 = motor_forces_trim(2);
    f3 = motor_forces_trim(3); f4 = motor_forces_trim(4);
    Utrim = [ -f1 - f2 - f3 - f4; ...
               (d/sqrt(2)) * (-f1 - f2 + f3 + f4); ...
               (d/sqrt(2)) * ( f1 - f2 - f3 + f4); ...
               km * (f1 - f2 + f3 - f4) ];
    U_NL = Utrim .* ones(4,nN);

    % Linearized sim (red dashed) using explicit hover linearization 
    x0_dev = x0_nl - var_trim;                               
    [tL, xDev] = ode45(@(t,xd) QuadrotorEOM_Linearized(t, xd, g, m, I, deltaFc, deltaGc), ...
                       t_span, x0_dev, opts);
    X_L  = (xDev.' + var_trim);                               
    nL   = numel(tL);
    U_L  = Utrim .* ones(4,nL);                              

    % Plot with your ORIGINAL plotting function 
    figs = (100*k + (1:6)).';                                
    PlotAircraftSim(tNL, X_NL, U_NL, figs, 'b-');             % nonlinear (blue)
    PlotAircraftSim(tL,  X_L,  U_L,  figs, 'r--');            % linearized (red dashed)

    for f = 1:6
        figure(figs(f));
        sgtitle(['Case ' num2str(k) ': ' caseNames{k} ' — Nonlinear (blue) vs Linearized (red dashed)']);
    end
end

%% LOCAL FUNCTIONS 
function var_dot = QuadrotorEOM(~, var, g, m, I, d, km, nu, mu, motor_forces)
% Nonlinear EOM (your structure)
u=var(4); v=var(5); w=var(6);
phi=var(7); theta=var(8); psi=var(9);
p=var(10); q=var(11); r=var(12);

Ixx=I(1,1); Iyy=I(2,2); Izz=I(3,3);
f1=motor_forces(1); f2=motor_forces(2); f3=motor_forces(3); f4=motor_forces(4);

Zc = -f1 - f2 - f3 - f4;
Lc = (d/sqrt(2)) * (-f1 - f2 + f3 + f4);
Mc = (d/sqrt(2)) * ( f1 - f2 - f3 + f4);
Nc = km * (f1 - f2 + f3 - f4);

Xa = -nu * u * abs(u);
Ya = -nu * v * abs(v);
Za = -nu * w * abs(w);
La = -mu * p * abs(p);
Ma = -mu * q * abs(q);
Na = -mu * r * abs(r);

R_BI = [cos(theta)*cos(psi),  sin(phi)*sin(theta)*cos(psi)-cos(phi)*sin(psi),  cos(phi)*sin(theta)*cos(psi)+sin(phi)*sin(psi);
        cos(theta)*sin(psi),  sin(phi)*sin(theta)*sin(psi)+cos(phi)*cos(psi),  cos(phi)*sin(theta)*sin(psi)-sin(phi)*cos(psi);
       -sin(theta),           sin(phi)*cos(theta),                              cos(phi)*cos(theta)];

pos_dot = R_BI * [u; v; w];
x_dot = pos_dot(1); y_dot = pos_dot(2); z_dot = pos_dot(3);

g_body = R_BI' * [0; 0; m*g];

Xc=0; Yc=0;
u_dot = (Xc + Xa + g_body(1))/m + r*v - q*w;
v_dot = (Yc + Ya + g_body(2))/m + p*w - r*u;
w_dot = (Zc + Za + g_body(3))/m + q*u - p*v;

phi_dot   = p + q*sin(phi)*tan(theta) + r*cos(phi)*tan(theta);
theta_dot = q*cos(phi) - r*sin(phi);
psi_dot   = q*sin(phi)/cos(theta) + r*cos(phi)/cos(theta);

p_dot = (Lc + La + (Iyy - Izz)*q*r)/Ixx;
q_dot = (Mc + Ma + (Izz - Ixx)*p*r)/Iyy;
r_dot = (Nc + Na + (Ixx - Iyy)*p*q)/Izz;

var_dot = [x_dot; y_dot; z_dot; u_dot; v_dot; w_dot; ...
           phi_dot; theta_dot; psi_dot; p_dot; q_dot; r_dot];
end

function motor_forces = control_to_motors(Zc, Lc, Mc, Nc, d, km)
A_inv = [-1/4,      -sqrt(2)/(2*d),  sqrt(2)/(2*d),   1/(4*km);
         -1/4,      -sqrt(2)/(2*d), -sqrt(2)/(2*d),  -1/(4*km);
         -1/4,       sqrt(2)/(2*d), -sqrt(2)/(2*d),   1/(4*km);
         -1/4,       sqrt(2)/(2*d),  sqrt(2)/(2*d),  -1/(4*km)];
motor_forces = A_inv * [Zc; Lc; Mc; Nc];
end

function xdot = QuadrotorEOM_Linearized(~, x_dev, g, m, I, deltaFc, deltaGc)
% Explicit hover linearization per provided equations.
% State order: [x y z u v w phi theta psi p q r]^T (all are deviations)
Ix = I(1,1); Iy = I(2,2); Iz = I(3,3);

% Unpack
dx   = x_dev(1);  dy   = x_dev(2);  dz   = x_dev(3); 
du   = x_dev(4);  dv   = x_dev(5);  dw   = x_dev(6);
dphi = x_dev(7);  dth  = x_dev(8);  dpsi = x_dev(9);
dp   = x_dev(10); dq   = x_dev(11); dr   = x_dev(12);

% Controls (deviations)
dZc = deltaFc;         
dLc = deltaGc(1); dMc = deltaGc(2); dNc = deltaGc(3);

% Kinematics
dxdot   = du;           dydot   = dv;           dzdot  = dw;
dphidot = dp;           dthdot  = dq;           dpsidot= dr;

% Translational dynamics (body)
dudot = -g * dth; % g*(-Δθ)
dvdot =  g * dphi; % g*(+Δφ)
dwdot = (1/m) * dZc; % vertical controlled by ΔZc

% Rotational dynamics
dpdot = (1/Ix) * dLc;
dqdot = (1/Iy) * dMc;
drdot = (1/Iz) * dNc;

xdot = [dxdot; dydot; dzdot; dudot; dvdot; dwdot; dphidot; dthdot; dpsidot; dpdot; dqdot; drdot];
end
